# Технические требования — Умный планировщик питания

## 1. Введение
**Умный планировщик питания** — интеллектуальная система, которая помогает пользователю составлять персонализированные недельные меню на основе его целей (похудение, набор массы, здоровое питание), бюджета и предпочтений.  
Пользователь вводит свои цели и загружает список доступных продуктов, система анализирует пищевую ценность и предлагает рецепты, а также генерирует список покупок.  
Цель проекта — сделать процесс питания более разнообразным, полезным и экономичным.

---

## 2. Use-cases

### UC1 — Загрузить список продуктов

| Поле              | Описание |
|-------------------|----------|
| **Название**      | Загрузить список продуктов |
| **Акторы**        | Пользователь (основной), Система (Умный планировщик питания) |
| **Предусловия**   | Пользователь авторизован в приложении; интернет‑соединение активно |
| **Основной сценарий** | 1. Пользователь открывает экран загрузки списка продуктов.<br>2. Пользователь вводит доступные продукты вручную или загружает файл.<br>3. Система анализирует список и отправляет его в Backend API.<br>4. Backend API сохраняет список в базе данных.<br>5. Система отображает подтверждение загрузки пользователю. |
| **Постусловия**   | Список продуктов сохранён в истории пользователя; пользователь видит результат на экране |

---

### UC2 — Получить персонализированные рецепты

| Поле              | Описание |
|-------------------|----------|
| **Название**      | Получить персонализированные рецепты |
| **Акторы**        | Пользователь (основной), Система (Умный планировщик питания) |
| **Предусловия**   | Пользователь авторизован; список доступных продуктов сохранён в системе |
| **Основной сценарий** | 1. Пользователь открывает экран «Рецепты».<br>2. Система отправляет список продуктов и цели пользователя в LLM API.<br>3. LLM API формирует список подходящих рецептов с учётом целей и бюджета.<br>4. Backend API получает список рецептов и сохраняет его в базе данных.<br>5. Система отображает список рецептов пользователю. |
| **Постусловия**   | Список рецептов сохранён в истории пользователя; рецепты отображаются на экране приложения |

---

### UC3 — Составить недельное меню

| Поле              | Описание |
|-------------------|----------|
| **Название**      | Составить недельное меню |
| **Акторы**        | Пользователь (основной), Система (Умный планировщик питания) |
| **Предусловия**   | Пользователь авторизован; в системе есть сохранённые рецепты |
| **Основной сценарий** | 1. Пользователь открывает экран «Меню».<br>2. Пользователь выбирает рецепты из предложенного списка.<br>3. Система формирует недельное меню на основе выбранных рецептов и целей пользователя.<br>4. Backend API сохраняет меню в базе данных.<br>5. Система отображает готовое меню пользователю. |
| **Постусловия**   | Составленное меню сохранено в истории пользователя; меню доступно для дальнейшего использования |

---

## 3. Функциональные требования
- Анализ пищевой ценности и оптимизация по калориям и стоимости.  
- Подбор рецептов на основе списка продуктов и целей пользователя (через LLM API).  
- Хранение:
  - пользователей и их истории запросов,  
  - проверенных рецептов (curated),  
  - сгенерированных рецептов (generated).  
- Поддержка диетических ограничений и фильтрации рецептов.  
- Планирование недельного меню с подсчётом калорий и БЖУ.  
- Генерация списка покупок на основе составленного меню.  
- Отправка уведомлений пользователям (push/email).  
- Администрирование базы рецептов и контента.  
- Поддержка мобильного и веб‑интерфейса.  

---

## 4. Нефункциональные требования и метрики производительности
- **Производительность:**  
  - Среднее время ответа Backend API ≤ 3 секунд (без учёта внешних API).  
  - 95-й перцентиль времени ответа ≤ 5 секунд.  
  - Среднее время анализа списка продуктов ≤ 5 секунд, 95-й перцентиль ≤ 7 секунд.  
- **Пропускная способность:** поддержка не менее 100 одновременных пользователей без деградации.  
- **Доступность:** Backend API ≥ 99% в месяц.  
- **Надёжность:** при сбое внешнего сервиса (анализ пищевой ценности, подбор рецептов, уведомления) система возвращает fallback‑ответ или сообщение об ошибке ≤ 1 секунды.  
- **Использование ресурсов:** загрузка CPU ≤ 70%, использование памяти ≤ 75% при пиковой нагрузке.  
- **Безопасность:** авторизация через JWT, шифрование соединений (HTTPS).  
- **Масштабируемость:** возможность горизонтального масштабирования Backend API.  
- **Удобство использования:** единый интерфейс для мобильного и веб‑клиента.  

---

## 5. Технологический стек
- **Frontend:** Flutter  
- **Backend:** Python/FastAPI  
- **Database:** PostgreSQL  
- **Интеграции:**  
  - VLM (анализ пищевой ценности)  
  - LLM API (подбор рецептов)  
  - Сервис уведомлений (push/email)  

---

## 6. Архитектурные принципы
- Используется модель **C4** для описания архитектуры:  
  - Context Diagram — пользователи и внешние системы.  
  - Container Diagram — мобильное/веб‑приложение, Backend API, база данных.  
  - Component Diagram — внутренняя структура Backend API.  
- Backend API реализует бизнес‑логику и взаимодействует с внешними сервисами.  
- Данные пользователей и рецептов хранятся централизованно в PostgreSQL.  
- Уведомления реализуются через внешний сервис (например, Firebase Cloud Messaging или аналог).  
- Принцип **Separation of Concerns**: разделение API, бизнес‑логики, интеграций и слоя данных.  
- Принцип **Fail-safe defaults**: при сбое внешнего сервиса система возвращает fallback‑ответ.  

---

## 7. Ограничения и допущения
- VLM‑модуль и LLM API предоставляются как внешние сервисы (не разрабатываются в рамках проекта).  
- Система ориентирована на работу в облачной инфраструктуре.  
- Поддерживаются только современные браузеры и мобильные ОС (Android, iOS).  
- Генерация рецептов LLM не гарантирует стабильности → администратор управляет curated‑репозиторием для контроля качества.  

---
